<html>
    <head>
    </head>
    <body>

        <h1>teste titulo 3</h1>

        <h1>Testando Git Primeira vez</h1>
        

        <h4>conetudo teste 4</h4>

        
        <p>ssh-keygen -t rsa -C "seu_email@provedor.com"</p>
        
        <p>git clone https://github.com/jcfonsecagit/repositorio.git</p>
        
        <p>git tag -- Ver versões</p>
        
        <p>git checkout v0.1 -- Como esta na primeira versão</p>
        

        <p>git diff v0.1 v0.2 -- Mudanças entre versões github</p>

        <h4>teste</h4>
        
        
        <p>git init ---- Como indicar que essa pasta será o nosso futuro repositório? Isso é feito a partir do seguinte comando </p>
        
      
        
        <p>git ls-files -- Já temos o nosso primeiro arquivo em nosso projeto. Mas, será que o git já sabe que o arquivo criado pertence ao repositório? Para tal, podemos verificar quais os arquivos que pertencem ao nosso repositório. Isso pode ser feito digitando o comando: </p>
        
        <p>git status -- E aí? Retornou algo? Nada? Onde está o nosso arquivo? Como fazemos para adiciona-lo no repositório? Para confirmar, podemos verificar o estado dos arquivos do nosso projeto </p>
        
        <p>git add nomeDoArquivo -- Com isso, podemos verificar que o nosso arquivo está na condição de Untracked files, isto é, ele não está na lista de arquivos cujas alterações serão rastreadas, ou controladas. Isso acontece porque o Git não sabe que deve controlar as alterações deste arquivo, ou seja, que ele deva fazer o track. Então, como dizemos ao Git que ele deve realizar o track? Isso é feito a partir do comando git add passando o nome do arquivo do qual o Git deve fazer o track. No nosso caso, queremos adicionar o arquivo index.html ao repositório.-- Depois ele muda para Changes to be commited (git add arquivo1 arquivo2 -- git add caminhoDoDiretorio -- git add .)</p>
        
        <p>git blame index.html -- O Git nos fornece uma funcionalidade onde podemos consultar quem foi o autor de cada linha de um arquivo através do comando</p>
        
        <p>Configurar o responsavel pela linha de código -- git config user.name "João Carlos Fonseca"
git config user.email "jcfonsecagit@gmail.com"</p>
        
        <p>git config --global user.name "João Carlos Fonseca"
git config --global user.email "jcfonsecagit@gmail.com" -- Porém, se quisermos fazer isso para outros repositórios, temos que dar o mesmo comando toda vez? Felizmente, o Git nos fornece a opção de definir um nome de usuário e e-mail para todo o sistema, isto é, deixando esta configuração global</p>
        
        <p>git commit -m "Início do projeto" -- A flag "-m", indica que o conteúdo a seguir é a mensagem que será utilizada para descrever o que está sendo feito no commit. Verificando os estados dos arquivos do nosso sistema com o comando git status, verificamos que não há nenhuma alteração em nosso projeto.</p>
        
        <p>git add -i  --   o modo interativo inicia um prompt de comando específico, aguardando as decisões do usuário sobre quais as alterações detectadas no working directory devem ser adicionadas ao index.</p>
        
        <p>git remote add origin https://github.com/Ariosmaia/curso-git.git  </p>
        <p>git remote</p>
        
        <p>git push origin master -- Envia atualizações</p>
        
        <p>git pull origin master -- Sincroniza com as novas atualizações</p>
        <p>Outra alternativa é utilizar, no primeiro push, a opção -u ou --set-upstream. Ela atrela a branch remota à local, fazendo com que não seja mais necessário passar como parâmetros a origem e a branch no comando push, que fica então assim: git push</p>
        
        <p>git log -- Ver os commites</p>
        
        <p>git whatchanged --- Ver os commites com mais detalhes</p>
        <p>Ao executarmos o comando git whatchanged -p é possível visualizar quais as linhas que foram modificadas em cada commit do nosso projeto. Obs: também é possível utilizarmos git log -p, que imprime também os commits nos quais não houve modificação.</p>
        
        <p>git branch design -- Cria um branch novo</p>
        <p>git branch -- consulta os branch's, paasando a opçãp -a as remotas são inclusas</p>
        <p>git checkout design ou mater -- Mudar de branch, com -b muda e cria pra nova brach</p>
        <p>add e commit são feitos normais</p>
        <p>git push -u origin design -- Fazer o push com o -u</p>
        <p>git branch -r -- Visualiza as branch's remotas</p>
        
        <p>git branch -t design origin/design -- Còpia a brach para p repo local</p>
        <p>git brach -d -- remove a brach</p>
        <p>git push -d origin design ou git push origin:design -- Remover a brach remota</p>
        
        <p>git fetch origin -- Verifica todas as atualizações no repo</p>
        
        <h1>Pull</h1>
        
        <h2>Exemplo: Dois desenvolvedores trabalha no mesmo arquivo, um muda a linha o h1 e outr muda o h4. O primeiro já fez o push atualiza o h1, quando o outro for atualizar vai dar erro. Então ele deve primeiro dar um pull. Assim irá atualizar ambos osarquivos, depois o push irá funcionar</h2>
        <p>git pull origin master -- Atualiza os arquivos anted de fazer o push, ele faz o merge caso tenha novas alteraçõe</p>
        
        <h3>Se tiver o conflito na mesma linha, o git dará o erro de conflito, vai aparecer as duas alteracões e o dev tem que escolher qual manter.</h3>
        
        
        <h1>Desafazendo erros</h1>
        <p>Quando fiz uma alteração e quero voltar: git checkout index.html</p>
        <p>Quando fizer a altereção + git add: git reset HEAD index.html</p>
        <p>Caso esteja fazendo varias alterações e descubra um erro de outro commit, como salvar meus dados para resolver o erro e depois continuar, uso o: git stash</p>
        <p>Como retornar a tarefa: git stash pop</p>
        <p>Se existe algum salvo no stash: git stash list -- para usar: git stash pop stash</p>
        <p>git stash drop: limpa a lista de stash</p>
        
        <h4>descantado commits indejados</h4>
        <p>Usamos o commit log e pegamos o HASH do "ultimo" commit: git reset jfdskfds7f8fjsklfjdskl8789fdsk</p>
        
        <h4>Desfazendo commits antigos</h4>
        <p>O ruim do reset q ele descartados todos os commits anteriores</p>
        <p>Então para ser mais especifico uso: git revert -n hash do commit</p>
        
        <h4>Buscando bug em muitos commits</h4>
        <p>Por exemplo a app para de funcionar, sabemos quando ele estava funcionando mais ou menos, vamos dar uma olhada: git checkout hash do commit</p>
        <p>Estava funcinando ok: git checkout HEAD .... Veremos quanto commits temos entre ele e o commit que estava funcionando</p>
        <p>Para testar os commits: git bisect start</p>
        <p>Vamos marcar o HEAD como ruim: git bisect bad HEAD</p>
        <p>Marcar o commit com estado bom: git bisect good hash do commit bom</p>
        
        <p>O git irá fazer uma busca entre esse dois ponto: Se estive bom: git bisect bad - Se estiver bom: git bisect good</p>
        <p>ELe segue esse ciclo de bad e good até o arquivo com problema</p>
        
        <p>QUando encontrar podemos: git reset, git revert, ou git show pra ver as modificações</p>
        
        
        
        
        
        
            
    </body>
</html>